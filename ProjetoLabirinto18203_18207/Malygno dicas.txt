atributos variaveis/ metodos auxiliares publicos é porquisse, faz privado encapsulado, declara um por um

encapsulamento(métodos auxiliares, atributos e variáveis) --> proteger em uma cápsula tudo aquilo que não é importante e perigoso de se ver,
aparecendo apenas as caracteristicas que não estão encapsuladas deixando visível apenas os métodos que implementam serviços para quie eles podem
ser chamados, deixando privativo os métodos auxiliares que não implementam serviços,são compositores dos que fazem serviços.tudo aquilo que 
alguém não deve usar. facilitando o trabalho do outro programador para evitar erros. À prova de Anta. Antas busters.

atributos e variáveis --> sempre são privativos,já os atributos constantes que julgamos que são úteis para outras partes do programa, podemos 
deixar públicos.

arquiteto de software --> decide os métodos, propriedades, atributos, classes que um programa deverá implementar. depois vai para a produção de 
um grande programa que dura muito tempo em etapas, dividindo o trabalho entre os membros de um grande equipe que produz os métodos base que não 
dependem de outros e depois vão juntando e os terminando de forma piramidal.

Classe: molde, forma, para moldar as peças, nela vão estar especificados todas as caracteristicas e funcionamentos das peças, criada uma vez só
usamos para todas as peças que precisarmos. Cada classe tem um propósito, não faça coisas demais em uma classe, faça classes específicas, o 
mesmo para um método, se ele for fazer mais que uma coisa, dividimos em 2 métodos. isso acaba com a reusabilidade.

Objeto: como entramos em contato com a peça, meio de acesso a instância, uma especifica.

Instância: a instância é uma peça, podemos ter uma instância sem associar um objeto, mas não temos como chegar nela de novo, só chamar um método,
para ser na mesma temos que ter um objeto. New --> criamos ela com esse comando.

horario x; x = acesso.
x.setHora(10); vai dar pau, não intanciamos o objeto, ele só está previsto a existir, deveria ter feito antes: x = new Horario(); .

é importante que ele teste de forma completa, mostra que as coisas funcionam ou não, não precisa de aparência e capricho.
Throw, assim como o return, é um comando abortivo, não precisa usar nada depois, else.

Só faça os contrutores nescessários e que forem ficar lógicos e funcionarem.
-------------------------------------------------------------------------------------------------------------------------------------------------
  Vocabulário Malígno:

LIFO = last in, first out.
FiFo = first in, first out.
++i = pré-incremento.
i++ = pós-incremento.
parametro formal = parametro que declaro quando estou declarando um método
-------------------------------------------------------------------------------------------------------------------------------------------------
  Sintaxe Malígna:

se um método recupera alguma informação, por padrão do Java, o nome dele começará copm get, os chamados "geters".
criar o vetor, depois criar o acesso e aí no fim definir o tamanho.
this é o objeto que eu usei. mexer na quatidade da pilha que foi usada para usar o guarde.
isGetter - se for um getter booleano sempre vai ter que ter um is antes do nome.
this = antes de atributos ou métodos.
Cada classe tem um propósito, não faça coisas demais em uma classe, faça classes específicas, o mesmo para um método, se ele for fazer mais que 
uma coisa, dividimos em 2 métodos. isso acaba com a reusabilidade. Reusar não é adaptar, alterar e modificar, é pegar a mesma coisa do jeito que
está e usar de novo.
throws Exception = método capaz de lançar excessões.
Nem sempre é bom usar else, melhor usar return. Ou testar o errado, nunca o certo, assim evitamos erros. Testamos a condição que dá errado e 
colocamos throw new Exception e no fim o que temos que fazer.
Chaves são obrigatórias em try e catch.
throwable = classe de herança do erros.
se formos usar float temos que colocar f no fiunal pois senão ele não reconhecerá e dará pau, como: 1.5f.
temos que usar type cast para evitar problemas, quando formos usar valores que geralmente são usados por 
outro tipo de variavel, assim: byte b = (byte)10; ou float f = (float)1.5;
Se formos fazer um método para alterar algum valor, o chamaresmo de setNome, os chamados setters.
Comentários são feitos com: /* */
Short circuit avaliation: se na ordem dos parâmetros booleanos ele verificar true, não acabou porém o resultado está determinado, ele 
conclui que a expressão dará true e não executa o resto, portanto se não houver instância alguma e pedirmos para avaliar se está vazia, ele não
 dará erro, pois ele terá verificadop aquele e se aquele estiver falso, logo não existe instâncioa e já está com o valor vazio, portanto ele 
pulará e fará o comando abaixo, ex: if(s==null || s.equals(""));
Devemos dar excessões contextualizadas para evitar confusões e esclarescer erros, não devemos deixar que o usuário veja elas sem termos 
contextualizado e muito menos a excessão default.
\" = escreve aspas em uma String.
\' = escreve apóstrofe em char.
\t = escreve com tabulação.
\n = escreve na linha seguinte.

Como transformar qualquer coisa em string:
qualquercoisa oi = valorquequalquercoisapodereceber	

	String s=""+oi; // truque para transformar em String.

podemos chamar métodos que convertem coisas também, como:

Otacoisa coisinha = coisaquecoisinhapodereceber;

Coisa alguma = Otacoisa.parseOtacoisa(coisinha);

Temos que fazer um try e um catch(o primeiro comando em que der erro, para a execução dos comandos do try e vai direto para o catch, não 
executando os outros comandos do try) se nosso programa lançar excessões. Nós as declaramos como objetos, pois de fato são, elas são do tipo 
exception, quando lançamos uma excessão ela é jogada no ar, então precisamos usar um catch para pegá-la e tratá-la.
ex: throw new Exception ("Não há nada a se apagar!"); = Exception problema; problema = new Exception("Não há nada a recuperar"); throw problema;

public class Program
{
	public static void main(string[] args)
	{
		try
		{
                   ...
                }
		catch(Exception erro) // está com a instância que o throw lançou
		{
			System.err.println(erro.getMessage());
		}
	}

}

mas o certo é estar no método em que o erro pode acontecer, pois ele tem que ser tratado no ponto em que ele ocorre, nem antes e nem depois, ele
deve ser tratado corretamente, num try catch. Se o método puder morrer(interromper a execução abruptamente sem chegar ao fim, voltando ao comando 
em que o método foi chamado), ele tem que ter throws Exception no cabeçalho(especialmente se não tratá-las).

Não existe o método toString() como herança em Java, precisamos fazê-lo, mesmo se não formos usar, pois assim ns enquadraremos na sociedade, na 
convenção, é obrigatório fazer.
ex: String saida = "A pilha: " = p; // chama o toString() automáticamente
			System.out.println(saida);

== = saber se objetos estão instanciados com a mesma instância
equals = se o conteúdo de um objeto for igual ao outro

                        Pilha p1, p3;
			p1 = new Pilha();
                        p3 = p1; // o nome p1 não vai guardar, mas a pessoa que leva o nome p1 vai

			int i = 0;

			while(!p1.isCheia())
			      p1.guarde("Arroz " + ++i);
                        
                        Pilha p2;
			p2 = new Pilha();

                        int i = 0;

                        while(!p2.isCheia())
			      p2.guarde("Arroz " + ++i);

                        if(p1==p2) // se fosse p1 == p3 ficaria iguais, pois levam a mesma instância, já esse dois não levam
                           System.out.println("iguais");
                        else
                           System.out.println("diferentes");

            String saida = "A pilha: " = p; // chama o toString() automáticamente
			System.out.println(saida);

Isso não é uma reação social, é você que não está sabendo programar" - Malygno

reação social = ter métodos obrigatórios, de acordo com as exigências da sociedade na convenção

Onde quer que se espere a instância de uma classe, aceita-se uma classe derivada indireta ou diretamente daquela que era esperada. 
Ex: throwable and the exceptions. Object, todas herdam dela.

Podemos ter vários métodos com mesmo nome desde que aceitem parâmetros de tipos diferentes, ou em quantidades diferentes de parâmetro.

Método Equals precisa ser feito e receber um Object como parâmetro. Mas precisamos instânciar o objeto antes de passá-lo como parâmetro, pois 
ele não chama o nome alfredo, mas sim a pessoa que leva o nome alfredo. Chamamos a instância, é antisse passar objeto sem instância ou null,
só números ficam com 0, mesmo assim é muita antisse.

Pilha pil = (Pilha)obj; // convenço o java de que a instância que está no obj é uma pilha e declaro um objeto da classe Pilha que recebe a
instância da Pilha(dá um nome para ele). Poderia usá-lo como obj(Pilha), assim evitaríamos usar mais memória.

Toda classe wrapper tem métodos próprios, como toString(), equals().

Se estamos na classe podemos mexer no atributo privado de qualquer classe do mesmo tipo.

return sai do fluxo de execução do método e volta alguma coisa no programa principal.

Método hashCode: gerar um número inteiro a partir dos dados do seu objeto, maracutaia com seus dados, ele deverá satisfazer algumas 
propriedades, dois objetos que o equals diz que são iguais, deverão ter o mesmo número inteiro retornado pelo hashCode, é inaceitavel que eles 
tenham número diferentes, já se o equals dizer que são diferentes, o número deve ser diferente(mas não é uma exigências), vamos tentar deixar 
diferentes, mas se forem iguais, não vamos nos suicidar, mas tem que ser com poucos objetos, raramente. Ele é uma espécie de chave primaria do
seu objeto, ele será importante para localizar ele muito rápidamente com Hash, por isso é fundamental que objetos iguais tenham os mesmos hash 
codes e objetos diferentes hash codes diferentes. Todas as classes wrappers tem hashCode, só um louco não codificaria ele. Dependendo do tipo da
classe que ele for chamado, devolverá um valor diferente. Se houver repetição degrada um pouco da mágica do Hash que foi feito para ser mágico,
então devemos evitar essas degradações. O que não é objeto não tem método, portanto se for um vetor de int, empacotamos o qtd que é um int e 
wmpacotamos em uma classe wrapper, então: ret = ret*2 + new Integer(this.qtd).hashCode();

public int hashCode()
    {
		int ret = 666; // pode ser qualquer valor, desde que não seja 0

		ret = ret*2 + new Integer(this.qtd).hashCode(); // qualquer número primo, pode variar nas outras linhas + hashCode de cada coisa
                // que tenho guardada dentro do meu objeto

		for(int i = 0; i < this.qtd; i++)
		 // if(this.vetor[i] != null, a rigor deveríamos fazer isso, mas nós codificamos métodos que não permitem isso, 
                 // no qtd não precisa pois fizemos uma instância
			ret = ret*2 + this.vetor[i].hashCode(); // envolver todos os dados, até os mais miudinhos, evita repetições

		return ret;
    }

seria interessante escolher um número menor que 666, como o 1, pois assim afastamos o problema de memória. o Número 2 é o melhor primo para isso.

UTC - universal Time Coordinate, quantos milisegundos passaram desde 1/1/1970, antes de 1970 = UTC negativo, se for depois, ele é UTC positivo.
usamos isso para calcular a semente do método Random.

"meninos não importa se bombar 1 ou meia dúzia, meninas não pode bombar nenhuma" - malygno

variáveis não guardam o conteúdo das variáveis, mas sim o endereço de memória deles, quando for requisitado o conteúdo, ela dará acesso ao 
conteúdo do endereço de memória. 

Com setters podemos alterar o conteúdo dos endereços de memória guardados pelas variáveis, assim passando por cima do private.

antas não podem mudar strings, pois não tem métodos que mudem Strings.

this.segundos<9?"0":"") + this.segundos;
		       // ou da zero ou vazia, se for true(menor que 9) coloco 0 antes do 9, se for false dá nada. Expressão condicional

quando sua classe tiver métodos além do contrutor que altera atributos, então sua classe tem que ter os métodos obrigatórios, método clone e 
construtor de cópia.

"se eu tenho condiçoes de tratar as excessões eu trato, senão eu coloco throws no cabeçalho" - malygno

se colocarmos o return do método em um try ou if, daraá erro de copilação. por isso usamos um truque de retornar uma variável qualquer do objeto.

		Horario ret = null; // "ela já era null, ai ele não enche o saco falando que ela não foi inicializada, poisd ela foi kkk"
				    //  - malygno

		try
		{
        	return new Horario(this);
	    	}
	    	catch(Exception ero) // "um catch vazio em geral é uma porquisse das grandes, pois significa que você está ignorando um erro, só 
                                     // podemos fazer assim se o erro não for acontecer, se tivermos certeza de que não vai(ele recebe this, e 
                                     // this não é nulo nunca!)" - Malygno
	    	{

	    	}

	    	return ret;

"se vamos guardar um treco que tem métodos além do contrutor que alteram atributos, não devemos guardar o treco, mas sim uma cópia dele, por isso
fazemos aquilo no final" - Malygno
        
        public void guarde (Horario s)
	{
		if(s==null || s.equals(""));
		   throw new Exception("Informação ausente!");

		if(isCheia())
			throw new exception("Número máximo de capacidade atingido!");

		// this.vetor[this.qtd] = (Horario)s.clone();
		this.vetor[this.qtd] = new Horario(s);
		this.qtd++;
	}

"quando vou dar algo para anta eu dou algo igualzinho ao meu, quando vou pegar algo dela, vou guardar algo igualzinho, mas não o dela, assim se 
for ferrar, ferra o dela, não no meu. Se não fizermos isso somos colocados em uma situação de poder ser taxados de antas" - Malygno

toda classe que for implementar esses dois métodos deve ter no cabeçalho: implements Cloneable.

se formos usar algo de antas, devemos implementar esses dois métodos, recebendo algum parâmetro que será guardado em uma variável privativa, se
não fizermos seremos irresponsáveis, seu antóide!

temos que ler a primeira linha do arquivo antes de usar uma classe feita por outra pessoa.

System.arraycopy(a, começodoa, b, começodob, qtd de elementos a partir do começo a serem copiados);

"eu guardo mas não altero o que guardei, jogo num clone" - tio ma

se não tiver nenhum ponteiro apontando a instância, o java a destrói, garbage collection.

-- obrigatorios de qualquer jeito:
-toString()
-equals()
-hashCode()

--somente se houver métodos que alteram atributos
-clone()
-construtor de cópia

--somente quando tem sentido e é possível pegar 2 objetos da sua classe(iguais), comparar e decidir entre 3 possibilidades
(o primeiro é maior, menor ou igual ao outro)
-compareTo()

No cabeçalho das classes que tiverem o método compareTo() terá: 
public class Horario implements Cloneable, Comparable<Horario> // horário é clonável, horário é comparável

CompareTo(): tem como missão comparar o this com o objeto da mesma classe que vier como parâmetro e deve retornar: um valor positivo se o this 
for maior, um valor negativo caso seja menor ou um valor nulo(0) caso o this e o parâmetro sejam iguais.

public int compareTo()
	{
		if(this.hora < outro.hora)
			return -666;

		if(this.hora > outro.hora) // se der falso quer dizer que as horas são iguais
			return 666;

		if(this.minutos < outro.minutos)
			return -666;

		if(this.minutos > outro.minutos)
			return 666;

		if(this.segundos < outro.segundos)
			return -666;

		if(this.segundos > outro.segundos)
			return 666;

		return 0;

		/* jeito supremo do Scherer(bem melhor)
		int segsDoThis, segsDoOutro;

		segsDoThis = this.segundos + this.minutos*60 + this.horas*3600;
		segsDoOutro = outro.segundos + outro.minutos*60 + outro.horas*3600;

		if(segsDoThis < segsDoOutro)
			return -666;

		if(segsDoThis < segsDoOutro)
			return 666;

		return 0;
		*/

		/* jeito do Hércules(bão também, ggzão)
		int segsDoThis, segsDoOutro;

		segsDoThis = this.segundos + this.minutos*60 + this.horas*3600;
		segsDoOutro = outro.segundos + outro.minutos*60 + outro.horas*3600;

		return segsDoThis - segsDoOutro;
		*/

		/* versão do Hércules malcompreendida pelo Malígno(demônio)
		int segsDoThis, segsDoOutro;

		segsDoThis = this.segundos + this.minutos*60 + this.horas*3600;
		segsDoOutro = outro.segundos + outro.minutos*60 + outro.horas*3600;

		return segsDoThis < segsDoOutro?-666:(segsDoThis > segsDoOutro?666:0);
		*/
	}

para ler valores digitados pelo usuário no console precisamos importar uma biblioteca do java:

depois instanciar essa classe:
bufferedReader teclado =
new bufferedReader(new InputStreamReader(
System.in));

para ler e colocar os valores no construtor:
System.out.println("Hora? ");
h = Integer.parseInt(teclado.readLine()); // var = classe.parse(outra classe);

System.out.println("Minutos? ");
m = Integer.parseInt(teclado.readLine());

System.out.println("Segundos? ");
s = Integer.parseInt(teclado.readLine());

Horario inicioAulas = new Horario(h; m; s);

Pilha<Horario> p = new Pilha<Horario>(5); // podemos fazer classes genericas que nescessariamente aceitam somente outras classes como parâmetros,
podemos colocar mais de um parâmetro, desde que ele esteja programado anteriormente: Pilha<Horario, Character>

pode ser um tipo de classe específica ou uma classe qualquer.

podemos permitir excessões por restringir o parâmetro com uma extensão da classe Throwable como: Pilha<Registro extends Throwable> ou que ele seja comparavel com 
outro como Pilha<Registro extends Comparable<x>>

porém o java não aceita vetores e instancia de tipos não estabelescidos, então substituimos por Object

"em qualquer lugar que se espera uma string e você mete um objeto chama o toString() e vira string" - Malygno
"eu não tenho nada com isso, a anta tem, você tem é só que não é a anta, pois codifiquei o hash code, ela não, culpa dela" - Malygno

string str = "BANANA";
char chr = str.charAt(2);

o código acima é bem simples, suponhamos agora que queiramos SOFRER... o que fazer? como tornar DEMONIACo o código acima?

Class<?> classe = str.getClass();
Integer parametroReal = 2; // 2 pq quero usar 2 como parâmetro do charAt
Class<?>[] tiposDosParametosFormais = new Class<?>[2]; // 1 pq charAt tem 1 parâmetro
tiposDosParametosFormais[0] = parametroReal.getClass();
Object[]parametrosReais = new Object[1]; // 1 pq charAt tem 1 parâmetro
parametrosReais[0] = parametroReal;
Method metodo = classe.getMethod("charAt", tiposDosParametosFormais);
char chr = ((character)metodo.invoke(parametrosReais)).charValue();

-jeito alternativo de se chamar um método, bem do capeta.

quando passamos um vetor sem posição indexada, vai todas as posições no parâmetro

a ordem também conta para sobrecarga dos métodos, além da quantidade e dos tipos de parâmetro

vetores e objetos são variáveis que guardam endereços de memórias, são ponteiros

só string poder ter cadeia vazia.

for(int i=0; i < this.qtd; i++) // porém se od dados forem iguais e estiverem em posições diferentes, dará falso, o que não deveria, 
// só o início é diferente.
	if (!this.vetor[i].equals(pil.vetor[i]))
		return false

"Computeiros pensam em tudo, tudo na vida, eles se dão bem pois pensam em tudo" - Tio Ma

O this pode ser omissivel desde que no contexto não cause ambiguidade por nome parecidos de atributos ou parâmetros ou objetos de outra classe.
não é bom omitir se não tivermos muita experiência e 2 objetos do mesmo tipo. As variáveis globais devem ser postas o this, os parâmetros não, 
se formos usá-los em um método juntos.

"Procure sempre fazer as soluções melhores possíveis, se seu colega fez uma solução melhor e mais bem feita, ele vai ter a nota máxima e você 
não" - malygno

o instrutor é para rodar enquanto você instancia e inicializar as variaveis de seu jeito, mas não precisamos de um contrutor para instanciar.
Todos os métodos da classe Math recebem e retornam double, não float.

Como usar Random:

while(!f.isCheia()) // 666001 números possíveis de 666 até 666666
            f.guarde(int(Math.random()*666001)+666); // vai até 666000 pois começa no 0, então somo 666, ai vai até 666666

o que causa uma lentidão em um programa é o loop, se ele não tiver loop, não importa quantos comando ele tenha, ele rodará extremamente rápido,
evite usar loops, pense sempre em tentar não usar loop, faça sempre uma versão sem. Temos que questionar os loops que fazemos, se ele não for 
essencial, ele será prejudicial para nosso programa.

<?> = não quero especificar a classe.

loop = 7 min.
sem loop = 1 segundo.

eclipse permite usar interfaces gráficas.

package poo.aula.janelas ou edu.cotuca.poo.janelas - new swing application

Classes gerenciadoras de layout:

BorderLayout = classe que fatia as suas janelas para elas ficarem bonitas, as bordas da janela, moldura de um quadro.
GridLayout = linhas e colunas, grade, matriz
AbsoluteLayout = coloco qualquer coisa que eu quero no lugar que eu quero, que nem C#. Não é bom usá-lo.

Containers
JFrame
JPanel

em uma fatia só coloca 1 coisa, por isso usamos o JPanel com um GridLayout para fatiar ele um pouco mais.
Label não pode ser mudado. O text box pode ser desabilitado, mas fica feio.
para ter espaços divididos é só fatiando.
Janelas e mains não são reaproveitáveis, então não precisa de métodos obrigatórios.
Só o conteúdo é recortável.
damos nomes próprios aos itens, variáveis

se tivermos uma preocupação de fazer as coisas muito bem feitas como as pessoas de antigamente, economizaremos muito mais espaço e velocidade, 
disquete guardava system, compilador, programas e editor de texto.Isso se perdeu com o avanço e barateamento da tecnologia que deixou as pessoas 
mais folgadas. Interface gráfica e programação visual. 80 - 85% de peso.

"Vai programar, inferno!!!' - malygno

é feio deixar em uma classe mais do que a main, mas podemos deixar uma classe dentro de outra desde que a que esteja dentro não seja 
reutilizável, como a classe Janela e a Tratador de Teclado.

quando herdamos métodos abstratos, dizemos que ela herdou um padrão de comportamento

programar pak man

4/10 - prova malígna: classes, métodos obrigatórios, construtor, herança (tudo bem feito); geralmente ele pede para fazer as clases e não a main
mas estude.

Robocode: É do demôniooo!

matriz = tipo[][] nome;

28/09 - trabalho malígno

"na classe herdada você pode implementar o método que você queria e mais nada, ai você terá todos os da classe mãe mais aquele que você queria na
classe mãe" - malygno

classe extends classeAHerdar
{
}

implements é herança heterogênea, classe herdando de interface. Já o contrario não pode acontecer.

clone, construtores (de cópia também) devem ser refeitos na classe que herda da outra( AgendaConsultavel herda de Agenda). Se não houver 
atributos a mais, não precisaremos refazer os outros métodos obrigatórios.

Os construtores da outra classe serão herdados mas não vão mais ser construtores e nem serão mais públicos.

por exemplo se refizermos o método equals(), na classe base, não fará diferença usar this.equals() já que não foi feita nenhuma mudança, porém se
refizermos na classe deriada, ele será o equals da classe derivada. Ela não terá acesso ao equals() da classe base. super.equals() é o da classe 
mãe.

é possível uma classe que herda de uma classe que herda de outra, classe mãe, filha, avó.

Não é possível herdar demais de uma classe, apenas uma classe(podendo ter interfaces) e muitas interfaces.

"quero calcular... sei lá, math.math" - malygno

"Não tem nada dela para criar as instâncias a partir dela, tudo o que tem lá é dela, por isso chamamos ela de uma classe não replicável, uma 
classe egoista, não é das instâncias é da classe, diferente das nossas classes criadas que são das instâncias, não dela, existem classes no meio 
termo como a classe Integer, uma forma de fazer objetos e instâncias e objeto com métodos próprios" - malygno

podemos omitir o nome da classe, mas é bom não omitir, pois pode confundir. A palavra static significa que o atributo é da classe e não da 
instância.

Instância de uma classe egoísta é oco, onde tudo é atributo e método dela, tudo é estático.

invoke = recebe 2 parâmetros, o chamante e o 

package são pacotes, ou seja, pastas que usamos normalmente.

os comentários de java possuem sintaxe, precisam ser colocados antes de coisas que sejam publicas ou protecteds, nem no meio do método, /** é o
início do comentário

documentação do método

@param
@return
@throws Exception

se fizermos esse tipo de comentário, ganhamos de prêmio um site de documentação.

java.util.regex  expressões regulares, para fazer validações

pattern

"^$" fim e começo = desde o começo até o fim 'x' não '%x%'
* quantas eu quiser do ultimo tipo digitado
[0-9]{5} 5 digitos de 0 a 9
9? 9 é opcional
?: grupo 
| ou
\\ força parentese a serem escritos
(?:\\([0-9]{2}\\) ) um abre grupo um abre parentes 2 digitos de 0-9 fecha parentese e um espaciho um fecha grupo, tudo isso opcional

patern.compile(classe.metodoDePattern)

verificar:

if(!Classe.metodoDePattern.matcher(campo).matches())
	throw new exception("Maaaliiignoooooo!!! Digita direitooooo");

esse metodo serve como um filtro

final = constante
static = da classe, é bom colocar static nas constantes

protected = meio termo entre private e public

a classe mãe possui atrinutos que ao serem herdados, serão da classe filha, porém vieram dela, se eles tiverem private, não poderão serem usados
pela filha, apenas através de métodos originários da mãe que usam ela, não os dela. Por isso se queremos permitir que a classe filha use eles e 
a turma do mesmo package( se quiser só quem herdar, coloque em pastas separadas, usamos protected, assim antas não mudam e classe filha pode usar

sem nada = default, todos poderiam usar, até os arquivos da mesma classe

super = meu, mas que foi herdado
this = meu, eu mesmo que fiz

quando não tem o daqui, o daqui é a mãe

arrumar projeto!!!!

throws exception = nos métodos que lançam excessões, só se a excessão não for tratada, se ela for, tipo em try e catch, não precisa.

métodos = 30 linhas no máximo, podem ser divididos em métodos menores
main não tem métodos, só a main

senão é programação estrutural, procedimentos e funções

parâmetros por referencia são ponteiros, objetos e vetores

podemos fazer ele ser um objeto para ser passado por referência ou ser uma cópia para não aleterar um objeito

PrintStream resultado = new PrintStream(new FileWriter(nomArqLab + ".res.txt"));
resultado.println(lab);
resultado.close();
-------------------------------------------------------------------------------------------------------------------------------------------------
  Comandos Malígnos:

ctrl 1 = compilar.
ctrl 2 = executar.
cmd:
javac.*.data
java.Program
-------------------------------------------------------------------------------------------------------------------------------------------------
Convenções

se não seguir, será alvo de mexericos. Podemos não seguir, mas o certo é seguir essas regirinhas:

Convenções de nomenclatura
1) Pacotes(biblioteca)
   tem seus nomes escritos totalmente com letras minúsculas e as palavras são separadas por(.).
2) Classes e Projetos
   palavras justapostas com iniciais maiúsculas e as demais letras minúsculas
3) Variáveis, atributos, variáveis locais e parâmetros
   Segue a regra 2 com a seguinte adaptação:
   a primeira palavra que forma o nome será totalmente minúscula
4) Constantes (final float PI = 3.14f;)
   tem seus nomes escritos totalmente com letras maiúsculas e as palavras são separadas por(_).

Obs: palavras reservadas pela linguagem e tipos escalares são totalente minúsculos

Método Equals precisa ser feito e receber um Object como parâmetro.
-------------------------------------------------------------------------------------------------------------------------------------------------
Tipos escalares

(vão dobrando a capacidade 1x2x2x2..., podem guardar 2 elevado ao número, byte = 8 bits --> 2^8 = 256 --> 256/2=128 --> -128 a 127 tirando o 0)
byte
short
int (ao ser declarado ele fica com o valor 0 na memória, nunca fica null, somente objetos)
long

float (equivalente ao tamanho do int)
double (equivalente ao tamanho do long)

char (ocupa 2 bytes, mas somente em java, pois ele usa mais caracteres, devido a internacionalização,
      porem os 256 primeiros são os da tabela ASCII já as outras usam somente 1 byte)

boolean

* String é uma classe. Pode ficar com valor nulo por não possuir uma instância ou possuir uma instância porém sem nenhum valor.
-------------------------------------------------------------------------------------------------------------------------------------------------
Conceitos

tipo = escalares, classe
variáveis = escalares, objetos
valores = escalares, instâncias
-------------------------------------------------------------------------------------------------------------------------------------------------
Classes Wrapper (se não tiver nada fica null, já os escalares ficam com o lxo de memória)

Byte
Short
Integer
Long

Float
Double

Character

Boolean

Ex:
public class program
{
    public static void main(String[] args)
    {
	int a, b = 7, c = 13; // ou usa Integer, porém só pode usar isso com Java, shortcut, faz automáticamente. Se pegamos um objeto de uma
                              // classe wrapper ele automáticamente cria instância e pega os valores
	a = (b+c)/2;
	
	System.out.println("A média de "+b+" e "+c+" vale "+a);
    }
}

// versão com Integer

public class program
{
    public static void main(String[] args)
    {
	int a, b = new Integer(7), c = new Integer(13);	
	
	a = new Integer((b.intvalue()+c.intvalue())/2;)
	
	System.out.println("A média de "+b.intvalue()+" e "+c.intvalue()+" vale "+a.intvalue());
    }
}

-- String (É CLASSE,NÃO TIPO ESCALAR!!! AAAAAA)

public class program
{
    public static void main(String[] args)
    {
	String a, b = "DanSama`s", c = "Project"; // poderia fazer: b = new String("DanSama`s");	
	
	a = b + " " + c; // seria: a = b.concat(new String(" ").concat(c)); * só podemos usar a instancia 1 vez na instância
	
	System.out.println(a);
    }
}

public class program *como converter qualquer coisa em string
{
    public static void main(String[] args)
    {
	qualquercoisa oi = valorquequalquercoisapodereceber
	
	String s=""+oi; // truque para transformar em String
	
	System.out.println(s);
    }
}

public class program
{
    public static void main(String[] args)
    {
	String rainbow = "8.7"; // poderia fazer: b = new String("DanSama`s");	
	
'	float arroz = Float.parseFloat(rainbow); // não tem truque, apenas usando o método
	
	System.out.println(a);
    }
}
-------------------------------------------------------------------------------------------------------------------------------------------------
Curiosidades Malígnas

Classes Wrapper tem duplo objetivo, servem de molde e de objeto(duas caras, pode ser uma forma ou uma peça), porém elas com os papeis 
difernciadospossuem métodos diferenciados, métodos para instâncias ou para classes, já algumas classes como a Math não tem duplo objetivo, não 
pode ser instânciada ou replicada.
-------------------------------------------------------------------------------------------------------------------------------------------------
Estruturas de dados

Variáveis são estruturas de dados, as escalares são as mais simples que há. Um vetor é um monte de variáveis de um tipo, junta, e ai temos uma 
estrutura de dados mais sofisticada e complexa. Uma classe é uma estrutura de dados, objetos também.

Hash - uma técnica de estrutura de dados, quando guardamos dados e precisarmos dele, vamos precisar buscá-lo entre todas as coisas que estão 
guardadas, a busca pode impactar na eficiência do seu programa, assim como loops. Fazer um algorítimo sem loops é melhor do que fazer um com 
loops melhor fazer menos loops, quando usamos loops encaixados, o impácto aumenta, drásticamente, melhor fazer eles separados, um loop depois 
em baixo outro... Loops encaixados tem efeito multiplicativo na hora de impactar na eficiência do seu programa.
Por isso usamos Hash que gasta a memória absurdamente, porém a busca fica rápida e instantânea, por isso não é frequentemente usada, mas a sua
performace na velocidade é inigualável, mas no uso de memória é ruim, independentemente do número de informações, ela achará ela instantâneamente

Você não vai usar essa estrutura porque uma anta impaciente quer, deixa ela lá dar os piti dela, se alguém não for morrer, não vamos usar essa 
estrutura, só é para ser usada em situações que justificam. - Malígno

Para elas funcionarem com a sua classe precisamos fazer o método obrigatório hashCode.